/***************************************************************************
 *  Title: Input 
 * -------------------------------------------------------------------------
 *    Purpose: Handles the input from stdin
 *    Author: Stefan Birrer
 *    Version: $Revision: 1.4 $
 *    Last Modification: $Date: 2009/10/12 20:50:12 $
 *    File: $RCSfile: interpreter.c,v $
 *    Copyright: (C) 2002 by Stefan Birrer
 ***************************************************************************/
/***************************************************************************
 *  ChangeLog:
 * -------------------------------------------------------------------------
 *    $Log: interpreter.c,v $
 *    Revision 1.4  2009/10/12 20:50:12  jot836
 *    Commented tsh C files
 *
 *    Revision 1.3  2009/10/11 04:45:50  npb853
 *    Changing the identation of the project to be GNU.
 *
 *    Revision 1.2  2008/10/10 00:12:09  jot836
 *    JSO added simple command line parser to interpreter.c. It's not pretty
 *    but it works. Handles quoted strings, and preserves backslash behavior
 *    of bash. Also, added simple skeleton code as well as code to create and
 *    free commandT structs given a command line.
 *
 *    Revision 1.1  2005/10/13 05:24:59  sbirrer
 *    - added the skeleton files
 *
 *    Revision 1.4  2002/10/24 21:32:47  sempi
 *    final release
 *
 *    Revision 1.3  2002/10/21 04:47:05  sempi
 *    Milestone 2 beta
 *
 *    Revision 1.2  2002/10/15 20:37:26  sempi
 *    Comments updated
 *
 *    Revision 1.1  2002/10/15 20:20:56  sempi
 *    Milestone 1
 *
 ***************************************************************************/
#define __INTERPRETER_IMPL__

/************System include***********************************************/
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include "string.h"

/************Private include**********************************************/
#include "interpreter.h"
#include "io.h"
#include "runtime.h"

/************Defines and Typedefs*****************************************/
/*  #defines and typedefs should have their names in all caps.
 *  Global variables begin with g. Global constants with k. Local
 *  variables should be in all lower case. When initializing
 *  structures and arrays, line everything up in neat columns.
 */
typedef struct string_l
{
  char* s;
  struct string_l* next;
} stringL;

int BUFSIZE = 512;
int MAXARGS = 100;
int aliased = 0;
aliasL* alias;

/**************Function Prototypes******************************************/

commandT*
getCommand(char* cmdLine);

void
freeCommand(commandT* cmd);

char* 
splitCmd(char*, int, char*);

void 
pipeSeq(char*, commandT*);

char* 
concatCmd(char*, char*);

/**************Implementation***********************************************/


/*
 * Interpret
 *
 * arguments:
 *   char *cmdLine: pointer to the command line string
 *
 * returns: none
 *
 * This is the high-level function called by tsh's main to interpret a
 * command line.
 */
void
Interpret(char* cmdLine)
{
  //printf("interpret");
  commandT* cmd = getCommand(cmdLine);
  //printf("before run cmd\n");
  RunCmd(cmd);
  //printf("past run cmd\n");
  freeCommand(cmd);
  //printf("seg here\n");
} /* Interpret */


/*
 * getCommand
 *
 * arguments:
 *   char *cmdLine: pointer to the command line string
 *
 * returns: commandT*: pointer to the commandT struct generated by
 *                     parsing the cmdLine string
 *
 * This parses the command line string, and returns a commandT struct,
 * as defined in runtime.h.  You must free the memory used by commandT
 * using the freeCommand function after you are finished.
 *
 * This function tokenizes the input, preserving quoted strings. It
 * supports escaping quotes and the escape character, '\'.
 */
commandT*
getCommand(char* cmdLine)
{
  //printf("here");
  char* restOfLine = (char*)malloc(sizeof(char)*BUFSIZE);
  //char* restCmdLine = (char*)malloc(sizeof(char)*BUFSIZE);

  commandT* cmd = malloc(sizeof(commandT) + sizeof(char*) * MAXARGS);
  cmd->argv[0] = 0;
  cmd->name = 0;
  cmd->argc = 0;
  cmd->piped = FALSE;
  cmd->next=NULL;
 
  int i, inArg = 0;
  char quote = 0;
  char escape = 0;

  // Set up the initial empty argument
  char* tmp = malloc(sizeof(char*) * BUFSIZE);
  int tmpLen = 0;
  tmp[0] = 0;

  //For aliasing:
  //aliasL* alias;
  char* keptString = 0; 
  //printf("parsing:%s\n", cmdLine);

  for (i = 0; cmdLine[i] != 0; i++)
    {
      //printf("\tindex %d, char %c\n", i, cmdLine[i]);

      // Check for whitespace
      if (cmdLine[i] == ' ')
        {
          if (inArg == 0)
            continue;
          if (quote == 0)
            {
              // End of an argument
              cmd->argv[cmd->argc] = malloc(sizeof(char) * (tmpLen + 1));
              strcpy(cmd->argv[cmd->argc], tmp);
              
	      //Get rest of command to add on to expanded command of alias
              if(cmd->argc==0){
                 if(isAlias(cmd->argv[0])){
                     alias=getAlias(cmd->argv[0]);
                     if(alias->found == FALSE){
                     keptString = splitCmd(cmdLine, i, restOfLine);
                     //printf("The rest of the string is: %s\n", keptString);
                     } 
                 }
              }
              

              inArg = 0;
              tmp[0] = 0;
              tmpLen = 0;
              cmd->argc++;
              cmd->argv[cmd->argc] = 0;
              continue;
            }
        }

      // If we get here, we're in text or a quoted string
      inArg = 1;

      // Start or end quoting.
      if (cmdLine[i] == '\'' || cmdLine[i] == '"')
        {
          if (escape != 0 && quote != 0 && cmdLine[i] == quote)
            {
              // Escaped quote. Add it to the argument.
              tmp[tmpLen++] = cmdLine[i];
              tmp[tmpLen] = 0;
              escape = 0;
              continue;
            }

          if (quote == 0)
            {
              //printf("\t\tstarting quote around %c\n", cmdLine[i]);
              quote = cmdLine[i];
              continue;
            }
          else
            {
              if (cmdLine[i] == quote)
                {
                  //printf("\t\tfound end quote %c\n", quote);
                  quote = 0;
                  continue;
                }
            }
        }

      // Handle escape character repeat
      if (cmdLine[i] == '\\' && escape == '\\')
        {
          escape = 0;
          tmp[tmpLen++] = '\\';
          tmp[tmpLen] = 0;
          continue;
        }

      // Handle single escape character followed by a non-backslash or quote character
      if (escape == '\\')
        {
          if (quote != 0)
            {
              tmp[tmpLen++] = '\\';
              tmp[tmpLen] = 0;
            }
          escape = 0;
        }

      // Set the escape flag if we have a new escape character sequence.
      if (cmdLine[i] == '\\')
        {
          escape = '\\';
          continue;
        }
      
      if(cmdLine[i] =='|'){
          cmd->piped =TRUE;
          i+=2;
          char* nextCmd = splitCmd(cmdLine, i, restOfLine);
          pipeSeq(nextCmd, cmd);
          //printf("%s\n",nextCmd);
          //cmd->piped =TRUE;
          //printf("Piped is %b\n", cmd->piped);
          break;
      }
      
      tmp[tmpLen++] = cmdLine[i];
      tmp[tmpLen] = 0;
    }

  
  // End the final argument, if any.
  if (tmpLen > 0)
    {
      //printf("\t\tend of argument %d, got:%s\n", cmd.argc, tmp);
      cmd->argv[cmd->argc] = malloc(sizeof(char) * (tmpLen + 1));
      strcpy(cmd->argv[cmd->argc], tmp);
      //cmd->next=0;
      inArg = 0;
      tmp[0] = 0;
      tmpLen = 0;
      cmd->argc++;
      cmd->argv[cmd->argc] = 0;
      //If input is an alias call expanded command
      if(isAlias(cmd->argv[0])){
         alias=getAlias(cmd->argv[0]);
         if(alias->found == FALSE){
        
	  char* concat = concatCmd(alias->origName, keptString); 
	  alias->found=TRUE;      
	  cmd = getCommand(concat);
	  alias->found=FALSE;
	  //free(concat);
         }
            
        // alias->found=FALSE;
      }
      
    }

  free(tmp);
  //TODO Maybe we Need the cmd Line?
  free(restOfLine);
  //free(restCmdLine);
  cmd->name = cmd->argv[0];

  return cmd;
} /* getCommand */

/*Get rest of commandline after stopping parsing procedure at certain point*/
char* 
splitCmd(char* cmdLine, int marker, char* restCmdLine){
   
    int i =0;
      
    while(cmdLine[marker] != '\0'){
    
      restCmdLine[i] = cmdLine[marker];
      marker++;
      i++;
    }
    restCmdLine[i]='\0';

    return restCmdLine;

}
/* Setup sequence of piped commands*/
void 
pipeSeq(char* cmdLine, commandT* prev){
      
      commandT* next = getCommand(cmdLine);
      next->piped = TRUE;      
      prev->next = next;
}

/* concatenate 2 strings*/
char* 
concatCmd(char* str1, char* str2){
   
   if(str2==NULL)
      return str1;

   char* concat = (char*)malloc(sizeof(char)*BUFSIZE);
    
   sprintf(concat,"%s %s", str1, str2);
      
   return concat;

}

/*
 * freeCommand
 *
 * arguments:
 *   commandT *cmd: pointer to the commandT struct to be freed
 *
 * returns: none
 *
 * This function frees all the memory associated with the given
 * commandT struct, before freeing the struct's memory itself.
 */
void
freeCommand(commandT* cmd)
{
  int i;

  cmd->name = 0;
  for (i = 0; cmd->argv[i] != 0; i++)
    {
      free(cmd->argv[i]);
      cmd->argv[i] = 0;
    }
  //free(cmd->next);
  free(cmd);
} /* freeCommand */
